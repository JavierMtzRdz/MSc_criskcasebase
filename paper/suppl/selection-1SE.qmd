---
title: "Real Dataset Analysis"
# author: Javier Mtz.-Rdz.
date-format: long
number-sections: true
number-depth: 4
fig-dpi: 400
format: 
  pdf:
    documentclass: article
    header-includes: |
      \usepackage[left=0.7in,right=0.7in,
      top=0.7in,bottom=0.5in,footskip=0.7in]{geometry} 
      \usepackage[document]{ragged2e}
      \usepackage{amsmath,amsthm,amssymb,amsfonts}
      \usepackage{mathtools}
      % Using kp fonts
      \usepackage{kpfonts}
      \usepackage{dsfont}
      \usepackage{centernot}
      \usepackage[usenames,dvipsnames,table]{xcolor}
      \usepackage{booktabs} % For improved table lines
      \renewcommand{\arraystretch}{1} % Increase row spacing
      \pagenumbering{arabic}
      \renewcommand\thefigure{\arabic{figure}}
    fontsize: 12pt
    colorlinks: true
knitr:
  opts_chunk:
    comment: "#>"
    message: FALSE
    echo: TRUE
    warning: FALSE
    dev: "png"
    fig.width: 8
    fig.height: 4.5
    fig.align: center
editor_options: 
  chunk_output_type: console
---

```{r preprocessing, include=FALSE}
# Setup ----
## Packages to use ----

#' To install mytidyfunctions, you need 
#' remotes::install_github("JavierMtzRdz/mytidyfunctions")
if (!require("pacman")) install.packages("pacman")
if (!require("mytidyfunctions")) remotes::install_github("JavierMtzRdz/mytidyfunctions")


pacman::p_load(tidyverse, janitor, writexl, 
              readxl, scales, mytidyfunctions,
              patchwork, here, bench, kableExtra,
              cbSCRIP)

library(casebase)
library(future.apply)
library(glmnet)
# library(mtool)
library(parallel)
library(tictoc)
library(tidyverse)
library(foreach)
library(survival)
library(cmprsk)
library(glue)
library(pec)
library(survminer)
library(rsample)



source(here(#"MSc_criskcasebase",
            "notes_jmr","code", "fitting_functionsV2.R"))
# source(here(#"MSc_criskcasebase",
#             "notes_jmr","code", "fitting_functionsV3.R"))

## Load fonts ----
extrafont::loadfonts(quiet = TRUE)

## Set theme ------
mytidyfunctions::set_mytheme(text = element_text(family = "Times New Roman"))


# Set-up process

save <- F

```

```{r}
# Load preprocessed dataset
bladder_comp_adj <- readRDS(here("paper", "data", "bladder_comp_adj.rds"))

# Create a stratified 75/25 split
set.seed(1234)
split <- initial_split(bladder_comp_adj, prop = 0.75, strata = event)

# Create training and testing data frames
train <- training(split)
test  <- testing(split)

# Verify the proportions
table(train$event) / nrow(train)
table(test$event) / nrow(test)
```

# Analysis without Clinical Vars

## cbSCRIP 
```{r}
# Set fitting parameters
if(save){
    
    set.seed(123)
    
    cv_nc <- cv_cbSCRIP(
        Surv(time, event) ~ .,
        train[,-(3:7), , drop = FALSE],
        alpha = 0.7,
        nfold = 5,
        nlambda = 50,
        ratio = 50)
    
    plot(cv_nc)
    
    saveRDS(cv_nc, here("paper",
                 "results",
                 glue("cv_nc.rds")))
}

cv_nc <- readRDS(here("paper", "results", glue("cv_nc.rds")))

# Print c-plot
plot(cv_nc)

# Print selected vars
## filter rows
filt_rows <- which(!same(cv_nc$fit.min$coefficients[,1], 0) | 
          !same(cv_nc$fit.min$coefficients[,2], 0)) 

cv_nc$fit.min$coefficients[filt_rows,]

# Fit model with Lambda(min + 1SE)
lambda_min_nc <- cv_nc$lambda.min
lambda_min_nc_idx <- which(lambda_min_nc == cv_nc$lambdagrid)
dev_lambda_nc <- cv_nc$deviance_mean[lambda_min_nc_idx]
se_lambda_nc <- cv_nc$deviance_se[lambda_min_nc_idx]
lambda_min_minus_se_idx <- which.min(abs(cv_nc$deviance_mean - (dev_lambda_nc + se_lambda_nc)))
lambda_min_minus_se <- cv_nc$lambdagrid[lambda_min_minus_se_idx]

# Fit model with Lambda(min + 1SE)
p1se_nc <- cbSCRIP(
        cb_data = cv_nc$cb_data, # using case-base sample generated by cv function
        alpha = 0.7,
        lambda = lambda_min_minus_se,
        ratio = 50)

# Print selected vars
filt_rows_p1se <- which(!same(p1se_nc$coefficients[[1]][,1], 0) | 
          !same(p1se_nc$coefficients[[1]][,2], 0)) 

p1se_nc$coefficients[[1]][filt_rows_p1se,]

# Repear refitting multiple times

if(save){
    
    set.seed(123)
    
    for (i in 1:50) {
    p1se_nc <- cbSCRIP(
        Surv(time, event) ~ .,
        train[,-(3:7), , drop = FALSE],
        alpha = 0.7,
        lambda = lambda_min_minus_se,
        fit_fun = fit_fun,
        ratio = 50)
    
    if(i== 1) {count_mtx <- !same(p1se_nc$coefficients[[1]],0)
    } else {
        count_mtx_loop <- !same(p1se_nc$coefficients[[1]],0)
        count_mtx_loop[] <- as.integer(!same(p1se_nc$coefficients[[1]],0))
        count_mtx[] <- count_mtx + count_mtx_loop
    }
    
    }
    
    saveRDS(count_mtx, here("paper",
                 "results",
                 glue("count_mtx.rds")))
}

count_mtx <- readRDS(here("paper", "results", glue("count_mtx.rds")))

filt_rows <- which(!same(count_mtx[,1], 0) | 
          !same(count_mtx[,2], 0)) 

# Number of variables selected out of 50
count_mtx[filt_rows,] 

```

## Cox elastic-net

```{r}
y <- Surv(time = train$time, 
          event = as.numeric(train$event == 1))

x <- model.matrix(event ~ . -time,
                  data = train[,-(3:7), , drop = FALSE])

set.seed(1234)
cox_enet_nc <- cv.glmnet(x = x, y = y, family = "cox",
                         # family = "binomial",
                         nfolds = 5,
                         alpha = 0.7)

plot(cox_enet_nc)

# Print selection
cc_enet_min_nc <- coef(cox_enet_nc, s = cox_enet_nc$lambda.min)

select_vars_enet_nc <- cc_enet_min_nc@Dimnames[[1]][-1][cc_enet_min_nc@i]

selected_coefs_enet_nc <- cc_enet_min_nc@x

names(selected_coefs_enet_nc) <- select_vars_enet_nc

selected_coefs_enet_nc

# Model w 1SE below

cox_lambda_min_nc <- cox_enet_nc$lambda.min
cox_lambda_min_nc_idx <- which(cox_lambda_min_nc == cox_enet_nc$lambda)
dev_cox_lambda_nc <- cox_enet_nc$cvm[cox_lambda_min_nc_idx]
se_cox_lambda_nc <- cox_enet_nc$cvsd[cox_lambda_min_nc_idx]
cox_lambda_min_minus_se_idx <- which.min(abs(cox_enet_nc$cvm - (dev_cox_lambda_nc + se_cox_lambda_nc)))
cox_lambda_min_minus_se <- cox_enet_nc$lambda[cox_lambda_min_minus_se_idx]

cc_enet_min_minus_se_nc <- coef(cox_enet_nc, s = cox_lambda_min_minus_se)

select_vars_enet_nc <- cc_enet_min_minus_se_nc@Dimnames[[1]][-1][cc_enet_min_minus_se_nc@i]

selected_coefs_enet_nc <- cc_enet_min_minus_se_nc@x

names(selected_coefs_enet_nc) <- select_vars_enet_nc

# Print corresponding variables

selected_coefs_enet_nc

```

## Cox lasso

```{r}
y <- Surv(time = train$time, 
          event = as.numeric(train$event == 1))

x <- model.matrix(event ~ . -time,
                  data = train[,-(3:7), , drop = FALSE])

set.seed(1234)
cox_lasso_nc <- cv.glmnet(x = x, y = y, family = "cox",
                         # family = "binomial",
                         nfolds = 5,
                         alpha = 0.7)

plot(cox_lasso_nc)

# Print selection
cc_lasso_min_nc <- coef(cox_lasso_nc, s = cox_lasso_nc$lambda.min)

select_vars_lasso_nc <- cc_lasso_min_nc@Dimnames[[1]][-1][cc_lasso_min_nc@i]

selected_coefs_lasso_nc <- cc_lasso_min_nc@x

names(selected_coefs_lasso_nc) <- select_vars_lasso_nc

selected_coefs_lasso_nc

# Model w 1SE below

cox_lambda_min_nc <- cox_lasso_nc$lambda.min
cox_lambda_min_nc_idx <- which(cox_lambda_min_nc == cox_lasso_nc$lambda)
dev_cox_lambda_nc <- cox_lasso_nc$cvm[cox_lambda_min_nc_idx]
se_cox_lambda_nc <- cox_lasso_nc$cvsd[cox_lambda_min_nc_idx]
cox_lambda_min_minus_se_idx <- which.min(abs(cox_lasso_nc$cvm - (dev_cox_lambda_nc + se_cox_lambda_nc)))
cox_lambda_min_minus_se <- cox_lasso_nc$lambda[cox_lambda_min_minus_se_idx]

cc_lasso_min_minus_se_nc <- coef(cox_lasso_nc, s = cox_lambda_min_minus_se)

select_vars_lasso_nc <- cc_lasso_min_minus_se_nc@Dimnames[[1]][-1][cc_lasso_min_minus_se_nc@i]

selected_coefs_lasso_nc <- cc_lasso_min_minus_se_nc@x

names(selected_coefs_lasso_nc) <- select_vars_lasso_nc

# Print corresponding variables

selected_coefs_lasso_nc

```


